// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common/network/components.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_common_2fnetwork_2fcomponents_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_common_2fnetwork_2fcomponents_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4023000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4023003 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_common_2fnetwork_2fcomponents_2eproto

PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_common_2fnetwork_2fcomponents_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable
    descriptor_table_common_2fnetwork_2fcomponents_2eproto;
class ClientConnect;
struct ClientConnectDefaultTypeInternal;
extern ClientConnectDefaultTypeInternal _ClientConnect_default_instance_;
class ClientDisconnect;
struct ClientDisconnectDefaultTypeInternal;
extern ClientDisconnectDefaultTypeInternal _ClientDisconnect_default_instance_;
class CreateComponent;
struct CreateComponentDefaultTypeInternal;
extern CreateComponentDefaultTypeInternal _CreateComponent_default_instance_;
class Packet;
struct PacketDefaultTypeInternal;
extern PacketDefaultTypeInternal _Packet_default_instance_;
class SpritePB;
struct SpritePBDefaultTypeInternal;
extern SpritePBDefaultTypeInternal _SpritePB_default_instance_;
class UpdateComponent;
struct UpdateComponentDefaultTypeInternal;
extern UpdateComponentDefaultTypeInternal _UpdateComponent_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template <>
::ClientConnect* Arena::CreateMaybeMessage<::ClientConnect>(Arena*);
template <>
::ClientDisconnect* Arena::CreateMaybeMessage<::ClientDisconnect>(Arena*);
template <>
::CreateComponent* Arena::CreateMaybeMessage<::CreateComponent>(Arena*);
template <>
::Packet* Arena::CreateMaybeMessage<::Packet>(Arena*);
template <>
::SpritePB* Arena::CreateMaybeMessage<::SpritePB>(Arena*);
template <>
::UpdateComponent* Arena::CreateMaybeMessage<::UpdateComponent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE


// ===================================================================


// -------------------------------------------------------------------

class SpritePB final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SpritePB) */ {
 public:
  inline SpritePB() : SpritePB(nullptr) {}
  ~SpritePB() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SpritePB(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpritePB(const SpritePB& from);
  SpritePB(SpritePB&& from) noexcept
    : SpritePB() {
    *this = ::std::move(from);
  }

  inline SpritePB& operator=(const SpritePB& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpritePB& operator=(SpritePB&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpritePB& default_instance() {
    return *internal_default_instance();
  }
  static inline const SpritePB* internal_default_instance() {
    return reinterpret_cast<const SpritePB*>(
               &_SpritePB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SpritePB& a, SpritePB& b) {
    a.Swap(&b);
  }
  inline void Swap(SpritePB* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpritePB* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpritePB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpritePB>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpritePB& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpritePB& from) {
    SpritePB::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpritePB* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "SpritePB";
  }
  protected:
  explicit SpritePB(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextureFieldNumber = 1,
  };
  // string texture = 1;
  void clear_texture() ;
  const std::string& texture() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_texture(Arg_&& arg, Args_... args);
  std::string* mutable_texture();
  PROTOBUF_NODISCARD std::string* release_texture();
  void set_allocated_texture(std::string* ptr);

  private:
  const std::string& _internal_texture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_texture(
      const std::string& value);
  std::string* _internal_mutable_texture();

  public:
  // @@protoc_insertion_point(class_scope:SpritePB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr texture_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};// -------------------------------------------------------------------

class ClientConnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientConnect) */ {
 public:
  inline ClientConnect() : ClientConnect(nullptr) {}
  ~ClientConnect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientConnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConnect(const ClientConnect& from);
  ClientConnect(ClientConnect&& from) noexcept
    : ClientConnect() {
    *this = ::std::move(from);
  }

  inline ClientConnect& operator=(const ClientConnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConnect& operator=(ClientConnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientConnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConnect* internal_default_instance() {
    return reinterpret_cast<const ClientConnect*>(
               &_ClientConnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientConnect& a, ClientConnect& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientConnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientConnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientConnect& from) {
    ClientConnect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientConnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ClientConnect";
  }
  protected:
  explicit ClientConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // string user = 2;
  void clear_user() ;
  const std::string& user() const;




  template <typename Arg_ = const std::string&, typename... Args_>
  void set_user(Arg_&& arg, Args_... args);
  std::string* mutable_user();
  PROTOBUF_NODISCARD std::string* release_user();
  void set_allocated_user(std::string* ptr);

  private:
  const std::string& _internal_user() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(
      const std::string& value);
  std::string* _internal_mutable_user();

  public:
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ClientConnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
    ::uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};// -------------------------------------------------------------------

class ClientDisconnect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ClientDisconnect) */ {
 public:
  inline ClientDisconnect() : ClientDisconnect(nullptr) {}
  ~ClientDisconnect() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ClientDisconnect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientDisconnect(const ClientDisconnect& from);
  ClientDisconnect(ClientDisconnect&& from) noexcept
    : ClientDisconnect() {
    *this = ::std::move(from);
  }

  inline ClientDisconnect& operator=(const ClientDisconnect& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientDisconnect& operator=(ClientDisconnect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ClientDisconnect& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientDisconnect* internal_default_instance() {
    return reinterpret_cast<const ClientDisconnect*>(
               &_ClientDisconnect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClientDisconnect& a, ClientDisconnect& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientDisconnect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientDisconnect* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientDisconnect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientDisconnect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ClientDisconnect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ClientDisconnect& from) {
    ClientDisconnect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientDisconnect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "ClientDisconnect";
  }
  protected:
  explicit ClientDisconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // uint64 id = 1;
  void clear_id() ;
  ::uint64_t id() const;
  void set_id(::uint64_t value);

  private:
  ::uint64_t _internal_id() const;
  void _internal_set_id(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:ClientDisconnect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};// -------------------------------------------------------------------

class UpdateComponent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UpdateComponent) */ {
 public:
  inline UpdateComponent() : UpdateComponent(nullptr) {}
  ~UpdateComponent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR UpdateComponent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateComponent(const UpdateComponent& from);
  UpdateComponent(UpdateComponent&& from) noexcept
    : UpdateComponent() {
    *this = ::std::move(from);
  }

  inline UpdateComponent& operator=(const UpdateComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateComponent& operator=(UpdateComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateComponent& default_instance() {
    return *internal_default_instance();
  }
  enum ComponentsCase {
    kSprite = 2,
    COMPONENTS_NOT_SET = 0,
  };

  static inline const UpdateComponent* internal_default_instance() {
    return reinterpret_cast<const UpdateComponent*>(
               &_UpdateComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(UpdateComponent& a, UpdateComponent& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateComponent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateComponent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateComponent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateComponent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateComponent& from) {
    UpdateComponent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateComponent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "UpdateComponent";
  }
  protected:
  explicit UpdateComponent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kSpriteFieldNumber = 2,
  };
  // uint64 entity_id = 1;
  void clear_entity_id() ;
  ::uint64_t entity_id() const;
  void set_entity_id(::uint64_t value);

  private:
  ::uint64_t _internal_entity_id() const;
  void _internal_set_entity_id(::uint64_t value);

  public:
  // .SpritePB sprite = 2;
  bool has_sprite() const;
  private:
  bool _internal_has_sprite() const;

  public:
  void clear_sprite() ;
  const ::SpritePB& sprite() const;
  PROTOBUF_NODISCARD ::SpritePB* release_sprite();
  ::SpritePB* mutable_sprite();
  void set_allocated_sprite(::SpritePB* sprite);
  private:
  const ::SpritePB& _internal_sprite() const;
  ::SpritePB* _internal_mutable_sprite();
  public:
  void unsafe_arena_set_allocated_sprite(
      ::SpritePB* sprite);
  ::SpritePB* unsafe_arena_release_sprite();
  void clear_components();
  ComponentsCase components_case() const;
  // @@protoc_insertion_point(class_scope:UpdateComponent)
 private:
  class _Internal;
  void set_has_sprite();

  inline bool has_components() const;
  inline void clear_has_components();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t entity_id_;
    union ComponentsUnion {
      constexpr ComponentsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SpritePB* sprite_;
    } components_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};// -------------------------------------------------------------------

class CreateComponent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CreateComponent) */ {
 public:
  inline CreateComponent() : CreateComponent(nullptr) {}
  ~CreateComponent() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR CreateComponent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateComponent(const CreateComponent& from);
  CreateComponent(CreateComponent&& from) noexcept
    : CreateComponent() {
    *this = ::std::move(from);
  }

  inline CreateComponent& operator=(const CreateComponent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateComponent& operator=(CreateComponent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateComponent& default_instance() {
    return *internal_default_instance();
  }
  enum ComponentsCase {
    kSprite = 2,
    COMPONENTS_NOT_SET = 0,
  };

  static inline const CreateComponent* internal_default_instance() {
    return reinterpret_cast<const CreateComponent*>(
               &_CreateComponent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CreateComponent& a, CreateComponent& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateComponent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateComponent* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateComponent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateComponent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateComponent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateComponent& from) {
    CreateComponent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateComponent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "CreateComponent";
  }
  protected:
  explicit CreateComponent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntityIdFieldNumber = 1,
    kSpriteFieldNumber = 2,
  };
  // uint64 entity_id = 1;
  void clear_entity_id() ;
  ::uint64_t entity_id() const;
  void set_entity_id(::uint64_t value);

  private:
  ::uint64_t _internal_entity_id() const;
  void _internal_set_entity_id(::uint64_t value);

  public:
  // .SpritePB sprite = 2;
  bool has_sprite() const;
  private:
  bool _internal_has_sprite() const;

  public:
  void clear_sprite() ;
  const ::SpritePB& sprite() const;
  PROTOBUF_NODISCARD ::SpritePB* release_sprite();
  ::SpritePB* mutable_sprite();
  void set_allocated_sprite(::SpritePB* sprite);
  private:
  const ::SpritePB& _internal_sprite() const;
  ::SpritePB* _internal_mutable_sprite();
  public:
  void unsafe_arena_set_allocated_sprite(
      ::SpritePB* sprite);
  ::SpritePB* unsafe_arena_release_sprite();
  void clear_components();
  ComponentsCase components_case() const;
  // @@protoc_insertion_point(class_scope:CreateComponent)
 private:
  class _Internal;
  void set_has_sprite();

  inline bool has_components() const;
  inline void clear_has_components();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::uint64_t entity_id_;
    union ComponentsUnion {
      constexpr ComponentsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::SpritePB* sprite_;
    } components_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};// -------------------------------------------------------------------

class Packet final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Packet) */ {
 public:
  inline Packet() : Packet(nullptr) {}
  ~Packet() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Packet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Packet(const Packet& from);
  Packet(Packet&& from) noexcept
    : Packet() {
    *this = ::std::move(from);
  }

  inline Packet& operator=(const Packet& from) {
    CopyFrom(from);
    return *this;
  }
  inline Packet& operator=(Packet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Packet& default_instance() {
    return *internal_default_instance();
  }
  enum CommandsCase {
    kClientConnect = 1,
    kClientDisconnect = 2,
    kUpdateComponent = 3,
    kCreateComponent = 4,
    COMMANDS_NOT_SET = 0,
  };

  static inline const Packet* internal_default_instance() {
    return reinterpret_cast<const Packet*>(
               &_Packet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Packet& a, Packet& b) {
    a.Swap(&b);
  }
  inline void Swap(Packet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Packet* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Packet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Packet>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Packet& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Packet& from) {
    Packet::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Packet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "Packet";
  }
  protected:
  explicit Packet(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientConnectFieldNumber = 1,
    kClientDisconnectFieldNumber = 2,
    kUpdateComponentFieldNumber = 3,
    kCreateComponentFieldNumber = 4,
  };
  // .ClientConnect client_connect = 1;
  bool has_client_connect() const;
  private:
  bool _internal_has_client_connect() const;

  public:
  void clear_client_connect() ;
  const ::ClientConnect& client_connect() const;
  PROTOBUF_NODISCARD ::ClientConnect* release_client_connect();
  ::ClientConnect* mutable_client_connect();
  void set_allocated_client_connect(::ClientConnect* client_connect);
  private:
  const ::ClientConnect& _internal_client_connect() const;
  ::ClientConnect* _internal_mutable_client_connect();
  public:
  void unsafe_arena_set_allocated_client_connect(
      ::ClientConnect* client_connect);
  ::ClientConnect* unsafe_arena_release_client_connect();
  // .ClientDisconnect client_disconnect = 2;
  bool has_client_disconnect() const;
  private:
  bool _internal_has_client_disconnect() const;

  public:
  void clear_client_disconnect() ;
  const ::ClientDisconnect& client_disconnect() const;
  PROTOBUF_NODISCARD ::ClientDisconnect* release_client_disconnect();
  ::ClientDisconnect* mutable_client_disconnect();
  void set_allocated_client_disconnect(::ClientDisconnect* client_disconnect);
  private:
  const ::ClientDisconnect& _internal_client_disconnect() const;
  ::ClientDisconnect* _internal_mutable_client_disconnect();
  public:
  void unsafe_arena_set_allocated_client_disconnect(
      ::ClientDisconnect* client_disconnect);
  ::ClientDisconnect* unsafe_arena_release_client_disconnect();
  // .UpdateComponent update_component = 3;
  bool has_update_component() const;
  private:
  bool _internal_has_update_component() const;

  public:
  void clear_update_component() ;
  const ::UpdateComponent& update_component() const;
  PROTOBUF_NODISCARD ::UpdateComponent* release_update_component();
  ::UpdateComponent* mutable_update_component();
  void set_allocated_update_component(::UpdateComponent* update_component);
  private:
  const ::UpdateComponent& _internal_update_component() const;
  ::UpdateComponent* _internal_mutable_update_component();
  public:
  void unsafe_arena_set_allocated_update_component(
      ::UpdateComponent* update_component);
  ::UpdateComponent* unsafe_arena_release_update_component();
  // .CreateComponent create_component = 4;
  bool has_create_component() const;
  private:
  bool _internal_has_create_component() const;

  public:
  void clear_create_component() ;
  const ::CreateComponent& create_component() const;
  PROTOBUF_NODISCARD ::CreateComponent* release_create_component();
  ::CreateComponent* mutable_create_component();
  void set_allocated_create_component(::CreateComponent* create_component);
  private:
  const ::CreateComponent& _internal_create_component() const;
  ::CreateComponent* _internal_mutable_create_component();
  public:
  void unsafe_arena_set_allocated_create_component(
      ::CreateComponent* create_component);
  ::CreateComponent* unsafe_arena_release_create_component();
  void clear_commands();
  CommandsCase commands_case() const;
  // @@protoc_insertion_point(class_scope:Packet)
 private:
  class _Internal;
  void set_has_client_connect();
  void set_has_client_disconnect();
  void set_has_update_component();
  void set_has_create_component();

  inline bool has_commands() const;
  inline void clear_has_commands();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union CommandsUnion {
      constexpr CommandsUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ClientConnect* client_connect_;
      ::ClientDisconnect* client_disconnect_;
      ::UpdateComponent* update_component_;
      ::CreateComponent* create_component_;
    } commands_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_common_2fnetwork_2fcomponents_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SpritePB

// string texture = 1;
inline void SpritePB::clear_texture() {
  _impl_.texture_.ClearToEmpty();
}
inline const std::string& SpritePB::texture() const {
  // @@protoc_insertion_point(field_get:SpritePB.texture)
  return _internal_texture();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SpritePB::set_texture(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.texture_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SpritePB.texture)
}
inline std::string* SpritePB::mutable_texture() {
  std::string* _s = _internal_mutable_texture();
  // @@protoc_insertion_point(field_mutable:SpritePB.texture)
  return _s;
}
inline const std::string& SpritePB::_internal_texture() const {
  return _impl_.texture_.Get();
}
inline void SpritePB::_internal_set_texture(const std::string& value) {
  ;


  _impl_.texture_.Set(value, GetArenaForAllocation());
}
inline std::string* SpritePB::_internal_mutable_texture() {
  ;
  return _impl_.texture_.Mutable( GetArenaForAllocation());
}
inline std::string* SpritePB::release_texture() {
  // @@protoc_insertion_point(field_release:SpritePB.texture)
  return _impl_.texture_.Release();
}
inline void SpritePB::set_allocated_texture(std::string* value) {
  _impl_.texture_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.texture_.IsDefault()) {
          _impl_.texture_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SpritePB.texture)
}

// -------------------------------------------------------------------

// ClientConnect

// uint64 id = 1;
inline void ClientConnect::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t ClientConnect::id() const {
  // @@protoc_insertion_point(field_get:ClientConnect.id)
  return _internal_id();
}
inline void ClientConnect::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ClientConnect.id)
}
inline ::uint64_t ClientConnect::_internal_id() const {
  return _impl_.id_;
}
inline void ClientConnect::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// string user = 2;
inline void ClientConnect::clear_user() {
  _impl_.user_.ClearToEmpty();
}
inline const std::string& ClientConnect::user() const {
  // @@protoc_insertion_point(field_get:ClientConnect.user)
  return _internal_user();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ClientConnect::set_user(Arg_&& arg,
                                                     Args_... args) {
  ;
  _impl_.user_.Set(static_cast<Arg_&&>(arg), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ClientConnect.user)
}
inline std::string* ClientConnect::mutable_user() {
  std::string* _s = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:ClientConnect.user)
  return _s;
}
inline const std::string& ClientConnect::_internal_user() const {
  return _impl_.user_.Get();
}
inline void ClientConnect::_internal_set_user(const std::string& value) {
  ;


  _impl_.user_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientConnect::_internal_mutable_user() {
  ;
  return _impl_.user_.Mutable( GetArenaForAllocation());
}
inline std::string* ClientConnect::release_user() {
  // @@protoc_insertion_point(field_release:ClientConnect.user)
  return _impl_.user_.Release();
}
inline void ClientConnect::set_allocated_user(std::string* value) {
  _impl_.user_.SetAllocated(value, GetArenaForAllocation());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.user_.IsDefault()) {
          _impl_.user_.Set("", GetArenaForAllocation());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ClientConnect.user)
}

// -------------------------------------------------------------------

// ClientDisconnect

// uint64 id = 1;
inline void ClientDisconnect::clear_id() {
  _impl_.id_ = ::uint64_t{0u};
}
inline ::uint64_t ClientDisconnect::id() const {
  // @@protoc_insertion_point(field_get:ClientDisconnect.id)
  return _internal_id();
}
inline void ClientDisconnect::set_id(::uint64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:ClientDisconnect.id)
}
inline ::uint64_t ClientDisconnect::_internal_id() const {
  return _impl_.id_;
}
inline void ClientDisconnect::_internal_set_id(::uint64_t value) {
  ;
  _impl_.id_ = value;
}

// -------------------------------------------------------------------

// UpdateComponent

// uint64 entity_id = 1;
inline void UpdateComponent::clear_entity_id() {
  _impl_.entity_id_ = ::uint64_t{0u};
}
inline ::uint64_t UpdateComponent::entity_id() const {
  // @@protoc_insertion_point(field_get:UpdateComponent.entity_id)
  return _internal_entity_id();
}
inline void UpdateComponent::set_entity_id(::uint64_t value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:UpdateComponent.entity_id)
}
inline ::uint64_t UpdateComponent::_internal_entity_id() const {
  return _impl_.entity_id_;
}
inline void UpdateComponent::_internal_set_entity_id(::uint64_t value) {
  ;
  _impl_.entity_id_ = value;
}

// .SpritePB sprite = 2;
inline bool UpdateComponent::has_sprite() const {
  return components_case() == kSprite;
}
inline bool UpdateComponent::_internal_has_sprite() const {
  return components_case() == kSprite;
}
inline void UpdateComponent::set_has_sprite() {
  _impl_._oneof_case_[0] = kSprite;
}
inline void UpdateComponent::clear_sprite() {
  if (components_case() == kSprite) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.components_.sprite_;
    }
    clear_has_components();
  }
}
inline ::SpritePB* UpdateComponent::release_sprite() {
  // @@protoc_insertion_point(field_release:UpdateComponent.sprite)
  if (components_case() == kSprite) {
    clear_has_components();
    ::SpritePB* temp = _impl_.components_.sprite_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.components_.sprite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SpritePB& UpdateComponent::_internal_sprite() const {
  return components_case() == kSprite
      ? *_impl_.components_.sprite_
      : reinterpret_cast<::SpritePB&>(::_SpritePB_default_instance_);
}
inline const ::SpritePB& UpdateComponent::sprite() const {
  // @@protoc_insertion_point(field_get:UpdateComponent.sprite)
  return _internal_sprite();
}
inline ::SpritePB* UpdateComponent::unsafe_arena_release_sprite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:UpdateComponent.sprite)
  if (components_case() == kSprite) {
    clear_has_components();
    ::SpritePB* temp = _impl_.components_.sprite_;
    _impl_.components_.sprite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void UpdateComponent::unsafe_arena_set_allocated_sprite(::SpritePB* sprite) {
  clear_components();
  if (sprite) {
    set_has_sprite();
    _impl_.components_.sprite_ = sprite;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UpdateComponent.sprite)
}
inline ::SpritePB* UpdateComponent::_internal_mutable_sprite() {
  if (components_case() != kSprite) {
    clear_components();
    set_has_sprite();
    _impl_.components_.sprite_ = CreateMaybeMessage< ::SpritePB >(GetArenaForAllocation());
  }
  return _impl_.components_.sprite_;
}
inline ::SpritePB* UpdateComponent::mutable_sprite() {
  ::SpritePB* _msg = _internal_mutable_sprite();
  // @@protoc_insertion_point(field_mutable:UpdateComponent.sprite)
  return _msg;
}

inline bool UpdateComponent::has_components() const {
  return components_case() != COMPONENTS_NOT_SET;
}
inline void UpdateComponent::clear_has_components() {
  _impl_._oneof_case_[0] = COMPONENTS_NOT_SET;
}
inline UpdateComponent::ComponentsCase UpdateComponent::components_case() const {
  return UpdateComponent::ComponentsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateComponent

// uint64 entity_id = 1;
inline void CreateComponent::clear_entity_id() {
  _impl_.entity_id_ = ::uint64_t{0u};
}
inline ::uint64_t CreateComponent::entity_id() const {
  // @@protoc_insertion_point(field_get:CreateComponent.entity_id)
  return _internal_entity_id();
}
inline void CreateComponent::set_entity_id(::uint64_t value) {
  _internal_set_entity_id(value);
  // @@protoc_insertion_point(field_set:CreateComponent.entity_id)
}
inline ::uint64_t CreateComponent::_internal_entity_id() const {
  return _impl_.entity_id_;
}
inline void CreateComponent::_internal_set_entity_id(::uint64_t value) {
  ;
  _impl_.entity_id_ = value;
}

// .SpritePB sprite = 2;
inline bool CreateComponent::has_sprite() const {
  return components_case() == kSprite;
}
inline bool CreateComponent::_internal_has_sprite() const {
  return components_case() == kSprite;
}
inline void CreateComponent::set_has_sprite() {
  _impl_._oneof_case_[0] = kSprite;
}
inline void CreateComponent::clear_sprite() {
  if (components_case() == kSprite) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.components_.sprite_;
    }
    clear_has_components();
  }
}
inline ::SpritePB* CreateComponent::release_sprite() {
  // @@protoc_insertion_point(field_release:CreateComponent.sprite)
  if (components_case() == kSprite) {
    clear_has_components();
    ::SpritePB* temp = _impl_.components_.sprite_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.components_.sprite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SpritePB& CreateComponent::_internal_sprite() const {
  return components_case() == kSprite
      ? *_impl_.components_.sprite_
      : reinterpret_cast<::SpritePB&>(::_SpritePB_default_instance_);
}
inline const ::SpritePB& CreateComponent::sprite() const {
  // @@protoc_insertion_point(field_get:CreateComponent.sprite)
  return _internal_sprite();
}
inline ::SpritePB* CreateComponent::unsafe_arena_release_sprite() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CreateComponent.sprite)
  if (components_case() == kSprite) {
    clear_has_components();
    ::SpritePB* temp = _impl_.components_.sprite_;
    _impl_.components_.sprite_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CreateComponent::unsafe_arena_set_allocated_sprite(::SpritePB* sprite) {
  clear_components();
  if (sprite) {
    set_has_sprite();
    _impl_.components_.sprite_ = sprite;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CreateComponent.sprite)
}
inline ::SpritePB* CreateComponent::_internal_mutable_sprite() {
  if (components_case() != kSprite) {
    clear_components();
    set_has_sprite();
    _impl_.components_.sprite_ = CreateMaybeMessage< ::SpritePB >(GetArenaForAllocation());
  }
  return _impl_.components_.sprite_;
}
inline ::SpritePB* CreateComponent::mutable_sprite() {
  ::SpritePB* _msg = _internal_mutable_sprite();
  // @@protoc_insertion_point(field_mutable:CreateComponent.sprite)
  return _msg;
}

inline bool CreateComponent::has_components() const {
  return components_case() != COMPONENTS_NOT_SET;
}
inline void CreateComponent::clear_has_components() {
  _impl_._oneof_case_[0] = COMPONENTS_NOT_SET;
}
inline CreateComponent::ComponentsCase CreateComponent::components_case() const {
  return CreateComponent::ComponentsCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Packet

// .ClientConnect client_connect = 1;
inline bool Packet::has_client_connect() const {
  return commands_case() == kClientConnect;
}
inline bool Packet::_internal_has_client_connect() const {
  return commands_case() == kClientConnect;
}
inline void Packet::set_has_client_connect() {
  _impl_._oneof_case_[0] = kClientConnect;
}
inline void Packet::clear_client_connect() {
  if (commands_case() == kClientConnect) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.commands_.client_connect_;
    }
    clear_has_commands();
  }
}
inline ::ClientConnect* Packet::release_client_connect() {
  // @@protoc_insertion_point(field_release:Packet.client_connect)
  if (commands_case() == kClientConnect) {
    clear_has_commands();
    ::ClientConnect* temp = _impl_.commands_.client_connect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.commands_.client_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientConnect& Packet::_internal_client_connect() const {
  return commands_case() == kClientConnect
      ? *_impl_.commands_.client_connect_
      : reinterpret_cast<::ClientConnect&>(::_ClientConnect_default_instance_);
}
inline const ::ClientConnect& Packet::client_connect() const {
  // @@protoc_insertion_point(field_get:Packet.client_connect)
  return _internal_client_connect();
}
inline ::ClientConnect* Packet::unsafe_arena_release_client_connect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.client_connect)
  if (commands_case() == kClientConnect) {
    clear_has_commands();
    ::ClientConnect* temp = _impl_.commands_.client_connect_;
    _impl_.commands_.client_connect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_client_connect(::ClientConnect* client_connect) {
  clear_commands();
  if (client_connect) {
    set_has_client_connect();
    _impl_.commands_.client_connect_ = client_connect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.client_connect)
}
inline ::ClientConnect* Packet::_internal_mutable_client_connect() {
  if (commands_case() != kClientConnect) {
    clear_commands();
    set_has_client_connect();
    _impl_.commands_.client_connect_ = CreateMaybeMessage< ::ClientConnect >(GetArenaForAllocation());
  }
  return _impl_.commands_.client_connect_;
}
inline ::ClientConnect* Packet::mutable_client_connect() {
  ::ClientConnect* _msg = _internal_mutable_client_connect();
  // @@protoc_insertion_point(field_mutable:Packet.client_connect)
  return _msg;
}

// .ClientDisconnect client_disconnect = 2;
inline bool Packet::has_client_disconnect() const {
  return commands_case() == kClientDisconnect;
}
inline bool Packet::_internal_has_client_disconnect() const {
  return commands_case() == kClientDisconnect;
}
inline void Packet::set_has_client_disconnect() {
  _impl_._oneof_case_[0] = kClientDisconnect;
}
inline void Packet::clear_client_disconnect() {
  if (commands_case() == kClientDisconnect) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.commands_.client_disconnect_;
    }
    clear_has_commands();
  }
}
inline ::ClientDisconnect* Packet::release_client_disconnect() {
  // @@protoc_insertion_point(field_release:Packet.client_disconnect)
  if (commands_case() == kClientDisconnect) {
    clear_has_commands();
    ::ClientDisconnect* temp = _impl_.commands_.client_disconnect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.commands_.client_disconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ClientDisconnect& Packet::_internal_client_disconnect() const {
  return commands_case() == kClientDisconnect
      ? *_impl_.commands_.client_disconnect_
      : reinterpret_cast<::ClientDisconnect&>(::_ClientDisconnect_default_instance_);
}
inline const ::ClientDisconnect& Packet::client_disconnect() const {
  // @@protoc_insertion_point(field_get:Packet.client_disconnect)
  return _internal_client_disconnect();
}
inline ::ClientDisconnect* Packet::unsafe_arena_release_client_disconnect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.client_disconnect)
  if (commands_case() == kClientDisconnect) {
    clear_has_commands();
    ::ClientDisconnect* temp = _impl_.commands_.client_disconnect_;
    _impl_.commands_.client_disconnect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_client_disconnect(::ClientDisconnect* client_disconnect) {
  clear_commands();
  if (client_disconnect) {
    set_has_client_disconnect();
    _impl_.commands_.client_disconnect_ = client_disconnect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.client_disconnect)
}
inline ::ClientDisconnect* Packet::_internal_mutable_client_disconnect() {
  if (commands_case() != kClientDisconnect) {
    clear_commands();
    set_has_client_disconnect();
    _impl_.commands_.client_disconnect_ = CreateMaybeMessage< ::ClientDisconnect >(GetArenaForAllocation());
  }
  return _impl_.commands_.client_disconnect_;
}
inline ::ClientDisconnect* Packet::mutable_client_disconnect() {
  ::ClientDisconnect* _msg = _internal_mutable_client_disconnect();
  // @@protoc_insertion_point(field_mutable:Packet.client_disconnect)
  return _msg;
}

// .UpdateComponent update_component = 3;
inline bool Packet::has_update_component() const {
  return commands_case() == kUpdateComponent;
}
inline bool Packet::_internal_has_update_component() const {
  return commands_case() == kUpdateComponent;
}
inline void Packet::set_has_update_component() {
  _impl_._oneof_case_[0] = kUpdateComponent;
}
inline void Packet::clear_update_component() {
  if (commands_case() == kUpdateComponent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.commands_.update_component_;
    }
    clear_has_commands();
  }
}
inline ::UpdateComponent* Packet::release_update_component() {
  // @@protoc_insertion_point(field_release:Packet.update_component)
  if (commands_case() == kUpdateComponent) {
    clear_has_commands();
    ::UpdateComponent* temp = _impl_.commands_.update_component_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.commands_.update_component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::UpdateComponent& Packet::_internal_update_component() const {
  return commands_case() == kUpdateComponent
      ? *_impl_.commands_.update_component_
      : reinterpret_cast<::UpdateComponent&>(::_UpdateComponent_default_instance_);
}
inline const ::UpdateComponent& Packet::update_component() const {
  // @@protoc_insertion_point(field_get:Packet.update_component)
  return _internal_update_component();
}
inline ::UpdateComponent* Packet::unsafe_arena_release_update_component() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.update_component)
  if (commands_case() == kUpdateComponent) {
    clear_has_commands();
    ::UpdateComponent* temp = _impl_.commands_.update_component_;
    _impl_.commands_.update_component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_update_component(::UpdateComponent* update_component) {
  clear_commands();
  if (update_component) {
    set_has_update_component();
    _impl_.commands_.update_component_ = update_component;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.update_component)
}
inline ::UpdateComponent* Packet::_internal_mutable_update_component() {
  if (commands_case() != kUpdateComponent) {
    clear_commands();
    set_has_update_component();
    _impl_.commands_.update_component_ = CreateMaybeMessage< ::UpdateComponent >(GetArenaForAllocation());
  }
  return _impl_.commands_.update_component_;
}
inline ::UpdateComponent* Packet::mutable_update_component() {
  ::UpdateComponent* _msg = _internal_mutable_update_component();
  // @@protoc_insertion_point(field_mutable:Packet.update_component)
  return _msg;
}

// .CreateComponent create_component = 4;
inline bool Packet::has_create_component() const {
  return commands_case() == kCreateComponent;
}
inline bool Packet::_internal_has_create_component() const {
  return commands_case() == kCreateComponent;
}
inline void Packet::set_has_create_component() {
  _impl_._oneof_case_[0] = kCreateComponent;
}
inline void Packet::clear_create_component() {
  if (commands_case() == kCreateComponent) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.commands_.create_component_;
    }
    clear_has_commands();
  }
}
inline ::CreateComponent* Packet::release_create_component() {
  // @@protoc_insertion_point(field_release:Packet.create_component)
  if (commands_case() == kCreateComponent) {
    clear_has_commands();
    ::CreateComponent* temp = _impl_.commands_.create_component_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.commands_.create_component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CreateComponent& Packet::_internal_create_component() const {
  return commands_case() == kCreateComponent
      ? *_impl_.commands_.create_component_
      : reinterpret_cast<::CreateComponent&>(::_CreateComponent_default_instance_);
}
inline const ::CreateComponent& Packet::create_component() const {
  // @@protoc_insertion_point(field_get:Packet.create_component)
  return _internal_create_component();
}
inline ::CreateComponent* Packet::unsafe_arena_release_create_component() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Packet.create_component)
  if (commands_case() == kCreateComponent) {
    clear_has_commands();
    ::CreateComponent* temp = _impl_.commands_.create_component_;
    _impl_.commands_.create_component_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Packet::unsafe_arena_set_allocated_create_component(::CreateComponent* create_component) {
  clear_commands();
  if (create_component) {
    set_has_create_component();
    _impl_.commands_.create_component_ = create_component;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Packet.create_component)
}
inline ::CreateComponent* Packet::_internal_mutable_create_component() {
  if (commands_case() != kCreateComponent) {
    clear_commands();
    set_has_create_component();
    _impl_.commands_.create_component_ = CreateMaybeMessage< ::CreateComponent >(GetArenaForAllocation());
  }
  return _impl_.commands_.create_component_;
}
inline ::CreateComponent* Packet::mutable_create_component() {
  ::CreateComponent* _msg = _internal_mutable_create_component();
  // @@protoc_insertion_point(field_mutable:Packet.create_component)
  return _msg;
}

inline bool Packet::has_commands() const {
  return commands_case() != COMMANDS_NOT_SET;
}
inline void Packet::clear_has_commands() {
  _impl_._oneof_case_[0] = COMMANDS_NOT_SET;
}
inline Packet::CommandsCase Packet::commands_case() const {
  return Packet::CommandsCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_common_2fnetwork_2fcomponents_2eproto_2epb_2eh
